/* FreeCarDetection Firmware
 * Author: I.Nagore
 * Date: 07/08/2022
 */
/* Includes ---------------------------------------------------------------- */

/********************************************************************************
-----> INCLUDES
********************************************************************************/
#include "BSP/spresense.h"   /* Include board defines */
#include <Servo.h>

#ifdef CAMERA_PRESENT
#include "LIB/CAMERA/inc/CameraSpresense.h"
#endif /* CAMERA_PRESENT */

#ifdef SDCARD_PRESENT
#include "LIB/SDCARD/inc/SDCardSpresense.h"
#endif /* SDCARD_PRESENT */

#ifdef LTE_PRESENT
#include "LIB/LTE/inc/LTESpresense.h"
#endif /* LTE_PRESENT */

#ifdef RTC_PRESENT
#include "LIB/RTC/inc/RTCSpresense.h"
#endif /* RTC_PRESENT */

#ifdef SERVO_PRESENT
#include "LIB/MOT/inc/ServoSpresense.h"
#endif /* SERVO_PRESENT */

#ifdef MQTT_PRESENT
#include "LIB/MQTT/inc/MQTTSpresense.h"
#include <ArduinoJson.h>
#include <ArduinoJson.hpp>
#endif /* MQTT_PRESENT */

#ifdef EDGE_IMPULSE_OBJECT_DETECTION_PRESENT
#include <CarParking_160_inferencing.h>                     /* Add library autogenerated with EdgeImpulse for object detection */
#endif /* EDGE_IMPULSE_OBJECT_DETECTION_PRESENT */

/********************************************************************************
-----> DEFINITIONS
********************************************************************************/
#define BAUDRATE  (115200)
#define LED0_ON   digitalWrite(LED0, HIGH)                    /* Macros for Switch on/off Board LEDs */
#define LED0_OFF  digitalWrite(LED0, LOW)
#define LED1_ON   digitalWrite(LED1, HIGH)
#define LED1_OFF  digitalWrite(LED1, LOW)
#define LED2_ON   digitalWrite(LED2, HIGH)
#define LED2_OFF  digitalWrite(LED2, LOW)
#define LED3_ON   digitalWrite(LED3, HIGH)
#define LED3_OFF  digitalWrite(LED3, LOW)

#define PICTURE_SIGNALLING_ON   LED0_ON                       /* Switch on LED when take a photo */
#define PICTURE_SIGNALLING_OFF  LED0_OFF                      /* Switch off LED when taken photo */

#ifdef SERVO_PRESENT
#define _NUMBER_OF_ANGLES_U     4                             /* Number of angles for the servo move to take photos */
#endif /* SERVO_PRESENT */

/********************************************************************************
-----> VARIABLES
********************************************************************************/
#ifdef SERVO_PRESENT
const uint8_t a6u8AngleArray[_NUMBER_OF_ANGLES_U] = { 15, 
                                                      50, 
                                                      100, 
                                                      150};   /* Angles to take photos. Can be changed depending your application. */
#endif /* SERVO_PRESENT */
#ifdef PROJECT_TAKE_PHOTOS
static uint32_t system_u32PhotosNumber = 0;                   /* Variable used to save number of taken photos */
#endif /* PROJECT_TAKE_PHOTOS */


/********************************************************************************
-----> Static Functions Prototype
********************************************************************************/
/**
 * @brief      Initialize all the peripherals used for the project (RTC, LTE, SDCard, Camera, MQTT, Servo...)
 */
void system_fnPeripheralsInitialize_vo(void);

/**
 * @brief      Takes a photo and it saves or check the presence of a car depending of the project definition
 */
bool system_fnPhotoTakeAndSave_b(void);
/**
 * @brief      Takes photos and check them in different angles to check a bigger range
 */
void system_fnCameraProcess_vo(void);

#ifdef EDGE_IMPULSE_OBJECT_DETECTION_PRESENT
float features[25600];  /* Variable to save the taken photo and check it through EdgeImpulse */
/**
 * @brief      Check Free car parking spaces thanks to the parameter image
 */
uint8_t system_fnCheckFreeSpaces_u8(CamImage Image);
/**
 * @brief      Converts from RGB565 to RGB888
 */
void r565_to_rgb(uint16_t color, uint8_t *r, uint8_t *g, uint8_t *b) ;
int raw_feature_get_data(size_t offset, size_t length, float *out_ptr);
#endif /* EDGE_IMPULSE_OBJECT_DETECTION_PRESENT */

#ifdef MQTT_PRESENT
/**
 * @brief      Check the car park status and send the result through MQTT to AWS IoT
 */
void system_fnMQTTProcess_vo(CamImage Image);
#endif /* MQTT_PRESENT */

/********************************************************************************
-----> Static Functions definition
********************************************************************************/
#ifdef EDGE_IMPULSE_OBJECT_DETECTION_PRESENT
/**
 * @brief      Copy raw feature data in out_ptr
 *             Function called by inference library
 *
 * @param[in]  offset   The offset
 * @param[in]  length   The length
 * @param      out_ptr  The out pointer
 *
 * @return     0
 */
int raw_feature_get_data(size_t offset, size_t length, float *out_ptr) {
    memcpy(out_ptr, features + offset, length * sizeof(float));
    return 0;
}

void r565_to_rgb(uint16_t color, uint8_t *r, uint8_t *g, uint8_t *b) 
{
    *r = (color & 0xF800) >> 8;
    *g = (color & 0x07E0) >> 3;
    *b = (color & 0x1F) << 3;
}
#endif /* EDGE_IMPULSE_OBJECT_DETECTION_PRESENT */

/****************************************************************************
 * setup
 ****************************************************************************/
void setup() 
{
  pinMode(LED0, OUTPUT);                /* LED0 as output. Used to signal taking a photo */
  Serial.begin(BAUDRATE);               /* Open serial communications and wait for port to open */
  while (!Serial)
  {
    ;
  }                                     /* Wait for serial port to connect. Needed for native USB port only */
  system_fnPeripheralsInitialize_vo();  /* Initialize all the peripherals used for the project (RTC, LTE, SDCard, Camera, MQTT, Servo...) */
}

void loop() 
{
#ifdef MQTT_PRESENT
  if(true == (RTC_fnIsAlarmActivated_b() || MQTT_fnIsMQTTRequestActivated_b()))
#else
  if(true == (RTC_fnIsAlarmActivated_b()))
#endif /*MQTT_PRESENT  */
  {
    system_fnCameraProcess_vo();      /* Take and photos in various angles and checks free car spaces and send result to AWS through MQTT protocol.*/

    RTC_fnClearAlarmFlag_vo();        /* Ensure alarm flag is cleared. */
#ifdef MQTT_PRESENT
    MQTT_fnClearMQTTRequestFlag_vo(); /* Ensure MQTT request flag cleared */
#endif /* MQTT_PRESENT */
  }

#ifdef MQTT_PRESENT
  MQTT_fnPoll_vo();                   /* Used to check if there's any data where we are subscribed */
#endif /* MQTT_PRESENT */
    
    delay(1000);
}

void system_fnPeripheralsInitialize_vo(void)
{
#ifdef LTE_PRESENT
  LTE_fnInitialize_b();
#endif /* LTE_PRESENT */

#ifdef SDCARD_PRESENT
   /* Initialize SD */
  SDCARD_fnInitialize_b();
#endif /* SDCARD_PRESENT */

#ifdef CAMERA_PRESENT
  CAMERA_fnInitialize_b();  
#endif /* CAMERA_PRESENT */

#ifdef RTC_PRESENT
  RTC_fnInitialize_vo(); 
  // Set the temporary RTC time
  RtcTime TimeLTE;
#ifdef LTE_PRESENT
  uint32_t LTETime = LTE_fnGetTime_u32();
  TimeLTE.unixtime(LTETime);
#else
  #error "You need to define the time if not obtained by LTE"
#endif /* LTE_PRESENT */
  RTC_fnSetTime_vo(TimeLTE);
#ifdef PROJECT_TAKE_PHOTOS
  RTC_fnSetAlarm_vo(DEFAULT_ALARM_TIME_SEC_U);   
#else  
  /* For this project we do not enable RTC alarm until the user needs/request it. */
#endif /* PROJECT_TAKE_PHOTOS */ 
#endif /* RTC_PRESENT */

#ifdef SERVO_PRESENT
 SERVO_fnInitialize_vo();
#endif /* SERVO_PRESENT */

#ifdef MQTT_PRESENT
  MQTT_fnInitialize_vo(); //Set certifications via SDCard and connect to the broker.
  MQTT_fnReceiveInit_vo();
#endif /* MQTT_PRESENT */
}

 #ifdef EDGE_IMPULSE_OBJECT_DETECTION_PRESENT
uint8_t system_fnCheckFreeSpaces_u8(CamImage Image)
{
    uint8_t u8RetFreeSpaces = 0;
 
    memcpy(features, Image.getImgBuff(), Image.getImgSize());

    uint8_t r, g, b;
    for(int i = 0; i<25600; i++)
    {
      r565_to_rgb(features[i], &r, &g, &b);
      // then convert to out_ptr format
      float pixel_f = (r << 16) + (g << 8) + b;
      features[i] = pixel_f;
    }
    
    ei_printf("Edge Impulse standalone inferencing (Arduino)\n");

    if (sizeof(features) / sizeof(float) != EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE) {
        ei_printf("The size of your 'features' array is not correct. Expected %lu items, but had %lu\n",
            EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, sizeof(features) / sizeof(float));
        delay(1000);
        return;
    }

    ei_impulse_result_t result = { 0 };

    // the features are stored into flash, and we don't want to load everything into RAM
    signal_t features_signal;
    features_signal.total_length = sizeof(features) / sizeof(features[0]);
    features_signal.get_data = &raw_feature_get_data;

    // invoke the impulse
    EI_IMPULSE_ERROR res = run_classifier(&features_signal, &result, false /* debug */);
    ei_printf("run_classifier returned: %d\n", res);

    if (res != 0) return;

    // print the predictions
    ei_printf("Predictions ");
    ei_printf("(DSP: %d ms., Classification: %d ms., Anomaly: %d ms.)",
        result.timing.dsp, result.timing.classification, result.timing.anomaly);
    ei_printf(": \n");
    ei_printf("[");
    for (size_t ix = 0; ix < 10; ix++) {
        ei_printf("%.5f", result.bounding_boxes[ix].value);
        if (ix != EI_CLASSIFIER_LABEL_COUNT - 1) {
            ei_printf(", ");
        }
    }
    ei_printf("]\n");

    // human-readable predictions
    for (size_t ix = 0; ix < 15; ix++) 
    {
        ei_printf("    %s: x = %d y = %d\n", result.bounding_boxes[ix].label, result.bounding_boxes[ix].x, result.bounding_boxes[ix].y);
        if(1 == strcmp("FreeCarPark",result.bounding_boxes[ix].label))
        {
          u8RetFreeSpaces++;
        }
    }

    return(u8RetFreeSpaces);
}
#endif /* EDGE_IMPULSE_OBJECT_DETECTION_PRESENT */

bool system_fnPhotoTakeAndSave_b(void)  
{
  CamImage Image;
  CamErr Error =  CAM_ERR_SUCCESS;

#ifdef PROJECT_TAKE_PHOTOS
  char filename[16] = {0};
  sprintf(filename, "PICT%03d.JPG", system_u32PhotosNumber);  /* Name for the image */
#endif /* PROJECT_TAKE_PHOTOS */
  
  Image = CAMERA_fnTakePicture_CamImage();                    /* Take a photo */

  if(false == CAMERA_fnIsImageAvailable_b(Image))
  {
    Serial.println("Failed to take picture");
  }
  else
  {
    LED0_ON;
#ifdef PROJECT_TAKE_PHOTOS
    system_u32PhotosNumber++;
    Serial.println("Save image");    
    SDCARD_fnSaveFile_vo(filename, Image.getImgBuff() ,Image.getImgSize()); /* Save image in SDCard */
    LED0_OFF;
#endif /* PROJECT_TAKE_PHOTOS */
#ifdef MQTT_PRESENT
    system_fnMQTTProcess_vo(Image);                   /* Process the photo to send the result through MQTT to AWS IoT */
#endif /* MQTT_PRESENT */
  }
  return(true);
}

void system_fnCameraProcess_vo(void)
{
  uint8_t u8ArrayCounter = 0;
  CAMERA_fnStart_b();
  for(u8ArrayCounter=0; u8ArrayCounter<(_NUMBER_OF_ANGLES_U); u8ArrayCounter++)
  {
    SERVO_fnMoveToAngle_vo(a6u8AngleArray[u8ArrayCounter]);
    sleep(1);
    system_fnPhotoTakeAndSave_b();
  }
  CAMERA_fnStop_vo();
}

#ifdef MQTT_PRESENT
void system_fnMQTTProcess_vo(CamImage Image)
{
  StaticJsonDocument<300> jsonDoc;
  String payload = "";
  uint8_t u8NumberFreeSpaces = 0;

  u8NumberFreeSpaces = system_fnCheckFreeSpaces_u8(Image);
  jsonDoc["FreeCarSpaces"] = u8NumberFreeSpaces;
  serializeJson(jsonDoc, payload);
  MQTT_fnSendMessage_vo(payload, MQTT_TOPIC);   //Send MQTT message.
}
#endif /* MQTT_PRESENT */
